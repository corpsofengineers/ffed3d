<Snaar> JohnJ: as in that fact does exist?
<JohnJ> Oh, that's not the one with the 0x30 offset...
<JohnJ> Ok, for normal objects, radius transformation goes like this:
<Snaar> so regarding previous question, what structure those offsets are for then
<JohnJ> The model structure.
<JohnJ> It makes a 16:16 fake-float using [model+0x14] + [model+0x18] + 7 as the exponent...
<JohnJ> And w[model+0x30] as the scale.
<JohnJ> Then it uses the ffp->64bit function which I'll have to look up.
<Snaar> оффсеты не для той структуры с размером 0x152 вообщем а для model структуры
<JohnJ> Result is stored in the 64-bit value at 0x140 in the 0x152 byte object structure.
<JohnJ> A similar thing is done with w[model+0x2c] and stored at 0x138 in the same structure.
<AlexDeadly> Hm... very interesting..
<Snaar> хм. я не знаю, тут в принципе понятно вроде и так? могу перевести конечно
<JohnJ> ffp->64 function simply returns mantissa << (exponent - 15)
<AlexDeadly> Я понял, Дримз придет, вот и спросим, надо переводить или нет...
<DreamZzz> я тут
<AlexDeadly> Читаешь?
<AlexDeadly> Все понятно?
<DreamZzz> сек
<JohnJ> So what you want is w[model+0x2c] << ([model+0x14] + [model+0x18] - 8), I think.
<JohnJ> Although it might be w[model+0x30]. Whichever is smaller :-)
* JohnJ can never remember which is inner and which is outer radius
<DreamZzz> где-то я такие вычисления видел
<JohnJ> I have no idea whether these are actually used for planets, but it makes sense.
<JohnJ> Of course, the starports will still float unless you hook that other function.

